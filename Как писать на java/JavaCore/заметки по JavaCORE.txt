............КЛАССЫ И ООП............
------------пакеты------------
Пакеты соответствуют физической структуре проекта, оргинизация каталогов, в которых находятся исходные файлы проекта
В пакете описываются классы. Всегда есть пакет по умлчанию, где хранятся не определённые классы.
package name;
Пакеты требуется подключать, кроме по умолчанию java.lang (например, String)
Другие пакеты импортируются
import java.name	//import java.* - подключается всё без разбору

Использование двух классов с одним и тем же названием из двух разных пакетов
И если нам надо одновременно использовать два этих класса, то необходимо указывать полный путь к этим классам в пакете:
java.util.Date utilDate = new java.util.Date();
java.sql.Date sqlDate = new java.sql.Date();

Статический импорт
Для этого вместе с директивой import используется модификатор static:
import static java.lang.Math.*;
public class Program { 
    public static void main(String[] args) {
        double result = sqrt(20); //класс Math имеет статический метод
    } 
}
Благодаря операции статического импорта мы можем использовать эти методы без названия класса. Например, писать не Math.sqrt(20), а sqrt(20)
------------модификаторы доступа------------
связаны с доступом из других классов и ПАКЕТОВ
их 4! а не 3, модификатор по умолчанию отличается от public тем, что не доступна видимость другим пакетам
наследникам досутупны все поля и методы (кроме private) базового класса даже если они находятся в другом пакете
------------типы данных------------
существуют примитивы и ссылочные типы данных
var переменная = значение (для определения типа, если не присвоить, то ошибка)
char: хранит одиночный символ в кодировке UTF-16 и занимает 2 байта

static
	память выделяется единоразово на этапе компиляции, явлется общим для всех объектов класса
	может использоваться без создания объекта (класса или ИНТЕРФЕЙСА)
	МОГУТ БЫТЬ ТОЛЬКО ФУНКЦИИ И ПОЛЯ (не классы, если конечно класс не вложенный/внутренний, а значит является полем внешнего класса)!
	значение определяется только в static методах, статическом инициализаторе, не обязательно до компиляции, НЕЛЬЗЯ в конструкторе, т.к. относится к классу, а не к объекту
final
	константа, присвоить значение можно только единожды
	нельзя наследоваться от final класса
	нельзя переопределять final методы
static final - действую все те же правила, НО нельзя использовать статический метод для присвоения значения, оно должно быть установлено в момент её объявления или в статическом блоке инициализации
*Про аргументы функции*
В методы аргументы примитивы передаются по значению
А аргументы ссылки - также, но передаётся копия ссылки на объект, поэтому:
-объект изменяется и изменения видны вне метода
-изменяется ссылка - аналогично примитивам, оригинальная ссылка не изменна

Параметры переменной длины.
String args[]
int ...nums (в данном случает ... обозначается, что кол-во аргументов не обязательное 0, 1... n)
------------исключения------------
Exception является базовым классом для всех исключений
может быть несколько блоков catch. Если у нас возникает исключение определенного типа, то оно переходит к соответствующему блоку catch.
------------классы------------
Статический инициализатор
static{
}
вызывается перед созданием самого первого объекта (до конструктора, а т.к. он статический, то единожды)

Вложенные (nested / внутренние, inner) классы.
-объекты такого класса могут быть созданы ТОЛЬКО внутри внешнего класса
-внутренний (не static!) /внешний класс имеет доступ ко всем полям внешнего/внутреннего класса, в том числе private
-объявить и описать его можно внутри любого контекста (тело метода, цикла...)
-внутренний класс можно объявить, как static, если требуется связь с внешним классом, но НЕ ДОСТУП к его ПОЛЯМ. Также не хранят ссылку на внешний объект, поэтому экономят память
------------наследование------------
-если конструктор определён родителем, то наследник должен его вызвать super(аргументы конснтруктора родителя)
-наследник может переопределять метод (даже не абстрактный) родителя @Override (аннотация не обязательна), а также может вызвать его super.OverrideMethod(аргументы метода, который переопределяется) если необходимы такие же действия. МОДИФИКАТОР ДОСТУПА должен быть не ниже, чем у родителя (например public родителя, поэтому переопределив нельзя сделать protected или private)
-наследование и переопределения можно запретить при помощи модификатора final к классу или методу соответственно

Person p = new Employee();
	может вызывать только методы, объявленные в классе Person,
	и переопределенные методы из класса Employee (по сути методы класса родителя только реализация дочернего).
	Однако она не может напрямую вызвать методы, которые уникальны для класса Employee.
Employee e = new Employee();
	может вызывать все методы класса Employee, включая те, которые уникальны для этого класса.
Использовать переменную родительского класса для хранения объектов любого из его дочерних классов.
	Например массив Person[] может хранить объекты как родителя, так и всех наследников.
	Например коллекцию различных подклассов можно обрабатывать одинаковым образом, как родителя.
------------приведение типов------------
-upcasting осуществляется автоматически
-downcasting иначе, от супер класса к подклассу нужно использовать преобразование типов
Object объект = new Наследник(); //
if(объект instanceof Наследника имяОбъектаНаследника){    
    имяОбъектаРодителя.ПереопределённыйМетодНаследника();
}
к интерфейсам применимо тоже самое
но я так и не понял в чём разница между:
Person p = new Person();
и
Object obj = new Person();
(Person)obj.GetName(); //разве что объект без приведения не имеет доступа к уникальным методам класса
------------абстрактные классы------------
-нельзя создать объект, выступает в качестве предоставления функционала для наследников
-если класс имеет хотя бы 1 abstract метод, то он обязан быть абстрактным
-наследники обязаны переопределить все abstract методы
-не абстрактные методы могут иметь релизацию, то есть его можно не переопределять, но использовать его сможет только дочерний (ведь объект родителя создать нельзя, т.к. он абстрактный)
------------интерфейсы------------
-определяет константы и методы
-методы по умолчанию public (могут быть и private читай ниже), константы public static final
-!Если класс НЕ РЕАЛИЗУЕТ какие-то методы интерфейса, 
	то такой класс ДОЛЖЕН БЫТЬ определен как АБСТРАКТНЫЙ, 
	а его НЕабстрактные КЛАССЫ-НАСЛЕДНИКИ затем ДОЛЖНЫ будут реализовать эти методы.
-нельзя создавать НАПРЯМУЮ объекты интерфейсов,
	но можно динамически, как экземпляр реализующих их классов
-множественная реализация интерфейсов (классу придётся реализовывать все методы)
-могут наследоваться (переопределение методов и использование их по умолчанию работает аналогично наследованию классов)
	пример: I1 имеет метод default и является родителем I2. I2 переопределяет этот метод не обозначая его абстрактным. Class имплементирует I2, но метод переопределён, не default, а значит его требуется реализовать 
	(если переопределить как default то зависит от того, какой метод имплементирует класс)
	(если не переопределять, то метод будет доступен классу в реализации I1)
-могут быть вложенными в классы -> всё тоже самое, как и было, только придётся указывать полное имя ИмяКласс.ИмяВложенногоИнтерфейса

//фишка, как с наследниками - Person p = new Employee(); / Employee e = new Employee(); -> см. -наследование-
Printable printable = new Book("Java. Complete Reference", "H. Shildt");
printable.print();      //  Java. Complete Reference (H. Shildt)
printable = new Journal("Foreign Policy");
printable.print();      // Foreign Policy

*модификаторы*
default методы:
	если метод интерфейса объявлен как по умолчанию, то такой метод может иметь реализацию
	если несколько класс имплементирует несколько интерфейсов (множественная реализация), которые имеют одинаковые сигнатуры default методов,
		то он обязан переопределить их (можно вызвать, как у супер-класса)
static методы -> IInterface.staticMethod(); //аналогично статическому методу класса (только тут интрфейс)
private методы: 
	НЕ могут быть default
	по определению используются только внутри интерфейса И ЛОГИЧНО внутри default методов
	не имеет значения static или нет, всё равно

*параметры и возвращаемые значения*
может быть и тем и тем, но нужно понимать, что в качестве объекта выступает экземпляр класса, но типа данных интерфейс
    static Printable read(Printable p){ //в качестве параметра класс имплементирующий интерфейс Printable printable = new Book();
        p.print();
	return new Journal(); //аналогично с типом возвращаемого значения
    }
также интерфейс может быть полем класса

*сравнение*
interface IPrint {
    default void Print(){
        System.out.println("interface, default method");
    }
}
abstract class AClass {
    void Print(){
        System.out.println("abstract class, not abstract method");
    }
}
class PClass{
    void Print(){
        System.out.println("parent class, not override");
    }
}
class Person1 implements IPrint{}
class Person2 extends AClass{}
class Person3 extends PClass{}
public class Main {
    public static void main(String[] args){
        Person1 p1 = new Person1();
        p1.Print();
        Person2 p2 = new Person2();
        p2.Print();
        Person3 p3 = new Person3();
        p3.Print();

        IPrint ip = new Person1();
        ip.Print();
        AClass ap = new Person2();
        ap.Print();
        PClass pp = new PClass();
        pp.Print();
    }
}
------------перечисления------------
методы:
	values() - возвращает массив всех констант перечисления
	ordinal() - возвращает порядковый номер определенной константы

могут определять константы, поля, методы. конструкторы по умолчанию private и никак иначе => вызывать его можно только внутри самого перечисления
enum Color{
    RED("#FF0000"), BLUE("#0000FF"), GREEN("#00FF00");
    private String code;
    Color(String code){
        this.code = code;
    }
    public String getCode(){ return code;}
}

методы можно определять для отдельных констант
Operation op = Operation.SUM;
op.action(1,2);

enum Operation{
    SUM{
        public int action(int x, int y){ return x + y;}
    },
    SUBTRACT{
        public int action(int x, int y){ return x - y;}
    },
    MULTIPLY{
        public int action(int x, int y){ return x * y;}
    };
    public abstract int action(int x, int y);
}
------------класс Object и его методы------------
*Методы класса Object*
-public final Class<?> getClass()
	Возвращает объект класса Class, представляющий тип времени выполнения объекта. Полезно для рефлексии.
-public int hashCode()
	Возвращает хэш-код для объекта. Этот метод используется для хэш-таблиц, таких как те, что предоставляются HashMap.
-public boolean equals(Object obj)
	Определяет, равен ли некоторый другой объект текущему объекту. Стандартная реализация проверяет, являются ли ссылки на объекты одинаковыми.
-protected Object clone() throws CloneNotSupportedException
	Создает и возвращает копию текущего объекта. Класс должен реализовать интерфейс Cloneable, чтобы использовать этот метод.
-public String toString()
	Возвращает строковое представление объекта. Стандартная реализация возвращает строку, состоящую из имени класса и хэш-кода.
-public final void notify()
	Пробуждает один поток, который ждет на мониторе объекта.
-public final void notifyAll()
	Пробуждает все потоки, которые ждут на мониторе объекта.
-public final void wait()
	Заставляет текущий поток ждать, пока другой поток не вызовет notify() или notifyAll() для этого объекта.
-public final void wait(long timeout)
	Заставляет текущий поток ждать указанное количество миллисекунд, пока другой поток не вызовет notify() или notifyAll() для этого объекта.
-public final void wait(long timeout, int nanos)
	Заставляет текущий поток ждать указанное количество времени, включая миллисекунды и наносекунды, пока другой поток не вызовет notify() или notifyAll() для этого объекта.
-protected void finalize() throws Throwable
	Вызывается сборщиком мусора, когда нет больше ссылок на объект. Может быть переопределен для освобождения ресурсов.

*Использование и переопределение*
-equals() и hashCode():
	Эти методы часто переопределяются для обеспечения правильной логики сравнения объектов и их корректной работы в коллекциях, таких как HashSet или HashMap.
-toString():
	Полезно переопределить для предоставления строкового представления объекта, что облегчает отладку и логирование.
-clone():
	Реализация интерфейса Cloneable и переопределение метода clone() позволяют создавать поверхностные копии объектов.
-wait(), notify(), notifyAll():
	Используются в многопоточном программировании для координации работы потоков.
-finalize():
	В современных приложениях используется редко, так как управление ресурсами лучше реализовать через try-with-resources и явное закрытие ресурсов.
------------Обобщения или Generics------------
позволяют создавать классы, интерфейсы и методы, которые работают с типами данных, указанных пользователем при создании экземпляра
	Это обеспечивает типовую безопасность, т.к. тип известен на этапе компилации
	повторное использование кода, т.к. для каждого типа не нужно писать свой класс или перегружать метод
Запреты
	в <> указывается класс! не работает с примитивами
	Нельзя создавать массивы параметризованных типов.
	Нельзя использовать обобщенные типы в статическом контексте.
	Нельзя создавать экземпляры параметризованных типов.
Можно
	несколько универсальных параметров <T, S>
	ограничивать набор типов через классы-наследники, классы имплементирующие некоторый интерфейс, тип данных класса/интефейрса
*Обощённые классы*
class Test<T>{
    private T id;
    Test(T id){
        this.id = id;
    }
    public T GetId() { return id; }
}

Test<String> t1 = new Test<String>(2);
Test<String> t2 = new Test<String>("2");
Test<String> t3 = new Test<String>("id");
t.GetId(); //вызов один и тот же у любого объекта

*Обобщённые интефейсы*
interface ITest<T>{
    T SomeMethod(T param);
}
1. Интерфейс задаёт конкретный тип, класс жёстко привязан в этому типу данных!
Class Test implements ITest<Тип Данных, например String>{
    String SomeMethod(String param){...};
}
2. Если класс обобщённый, то он может позволить себе универсальный параметр, как определено в интерфейсе
Class Test<T> implements ITest<T>{
    T SomeMethod(T param){...};
}

*обобщённые методы*
	также можно поступить и с конструктором
public <T> void print(T[] items){
        for(T item: items){
            System.out.println(item);
        }
    }
}
крч аналогично классу, только тип данны определяется при вызове метода, а не создании объекта

*ограничения обобщений*
ограничить по набору типов:
	Class Test<T extends SomeClassPerent> //доступны только SomeClassPerent или его наследники
	Class Test<T implements ITest>{} //доступны только классы имплементирующие интфейс ITest
	Class Test<T extends SomeClassPerenеt & Itest> //МНОЖЕСТВЕННОЕ ОГРАНИЧЕНИЕ! класс Test может работать только с объектами, которые реализуют интерфейс и явлются наследниками класса-родителя
интерфейс или класс может жёстко привязать в типу данных:
	Class Test implements ITest<String>{} //реализация интерфейса жёстко с типом String
	Class Test<T extends SomeClass<String>>{} //ограничение обобщения к жёсткой привязке к типу

*наследование обобщённых классов*
Обобщенные классы могут участвовать в иерархии наследования: могут наследоваться от других, либо выполнять роль базовых классов.
-базовый обощённый класс
	*класс-наследник должен передавать данные о типе в конструкции базового класса
	class DepositAccount<T> extends Account<T>{}
	*класс-наследник должен может добавлять и использовать какие-то свои параметры типов
	class DepositAccount<T, U> extends Account<T>{}
	*не быть обобщённым, НО тогда придётся определить тип данных!
	class DepositAccount extends Account<Integer>{}
-обобщённый класс наследник, тут использование конструкций базового класса в наследнике проиходит, как обычно
-преобразование обобщённых типов, можно привести объект SomeClass<Integer> к Test<Integer> или SomeClass<String> к Test<String> //SomeClass<T> extends Test<T>
------------record------------
record название (поле1, поле2,...полеN){
    // тело record
}
например:
record Person(String name, int age) { }
-поля являются private final
-имеют метод возвращения значения, например name(), age()
-автоматически будут создаваться методы equals, hashCode и toString
-можно переопределять конструктор:
record Person(String name, int age) { 
    Person{
        if(age<1 || age > 110){
            age = 18;
        }
    }
}
или
record Person(String name, int age) { 
    Person(String firstName, String lastName, int age){ //НО ОБЯЗАТЕЛЬНО НУЖНО КАНОНИЧЕСКИЙ КОНСТРУКТОР
        this(firstName + " " + lastName, age);
    }
}

record - канониченый конструктор, тоже самое что и ниже, но кода меньше:
class Person {
    private final String name;
    private final int age;
 
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
 
    String name() { return name; }
    int age() { return age; }
 
    public boolean equals(Object o) {
        if (!(o instanceof Person)) return false;
        Person other = (Person) o;
        return other.name == name && other.age == age;
    }
 
    public int hashCode() {
        return Objects.hash(name, age);
    }
 
    public String toString() {
        return String.format("Person[name=%s, age=%d]", name, age);
    }
}
------------Исключения------------
Базовым классом для всех исключений является класс Throwable. От него уже наследуются два класса: Error и Exception. Все остальные классы являются производными от этих двух классов.
https://metanit.com/java/tutorial/4.2.php
-Проверяемые исключения являются подклассами Exception (например: IOException, SQLException, ClassNotFoundException...)
	компилятор требует, чтобы такие методы обрабатывал программист
	Обычно используются для указания на условия, которые могут быть восстановлены или обработаны программой (например, отсутствие файла)
-Непроверяемые исключения (например: NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException... тут же и деление на 0 например)
	являются подклассами RuntimeException (который подкласс Exception)
	компилятор не требует от программиста обработки этих исключений
	Обычно используются для указания на программные ошибки, которые, как правило, не могут быть восстановлены (например, деление на ноль).
Методы класса Exeption:
-Метод getMessage() возвращает сообщение об исключении
-Метод getStackTrace() возвращает массив, содержащий трассировку стека исключения
-Метод printStackTrace() отображает трассировку стека

*Свои классы-исключения*
Пример:
-Здесь для определения ошибки, связанной с вычислением факториала, определен класс FactorialException, 
который наследуется от Exception и 
который содержит всю информацию о вычислении. 
В конструкторе FactorialException в конструктор базового класса Exception передается сообщение об ошибке:  super(message). 
Кроме того, отдельное поле предназначено для хранения числа, факториал которого вычисляется.
-Для генерации исключения в методе вычисления факториала выбрасывается исключение с помощью оператора throw: throw new FactorialException("Число не может быть меньше 1", num). 
Кроме того, так как это исключение не обрабатывается с помощью try..catch, то мы передаем обработку вызывающему методу, используя оператор throws: public static int getFactorial(int num) throws FactorialException

............КОЛЛЕКЦИИ............
............ПОТОКИ............
............ЛЯМБДА............
............МНОГОПОТОЧНОСТЬ............
............СТРИМЫ............
............СЕТИ............