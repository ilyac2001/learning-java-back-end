package recursion;

import org.jetbrains.annotations.NotNull;

import java.util.Arrays;

/**
 * Рекурсивные алгоритмы могут быть полезны и удобны для решения задач, которые естественно решаются с использованием рекурсии.
 *
 * <ul>
 *     <li><b>Задачи, решаемые методом "разделяй и властвуй"</b>:
 *     <ul>
 *         <li>Примеры: Быстрая сортировка (Quick Sort), сортировка слиянием (Merge Sort).</li>
 *         <li>Эти задачи включают деление проблемы на подпроблемы меньшего размера, решение подпроблем и комбинирование их результатов.</li>
 *     </ul>
 *     </li>
 *
 *     <li><b>Обход структур данных</b>:
 *     <ul>
 *         <li>Примеры: Обход деревьев (дерево решений, двоичное дерево поиска), обход графов.</li>
 *         <li>Рекурсия позволяет естественно и лаконично обходить узлы деревьев или графов.</li>
 *     </ul>
 *     </li>
 *
 *     <li><b>Задачи с повторяющимися подпроблемами</b>:
 *     <ul>
 *         <li>Примеры: Числа Фибоначчи, задачи динамического программирования (если используется мемоизация).</li>
 *         <li>Рекурсия позволяет выразить задачу в виде рекурсивного соотношения.</li>
 *     </ul>
 *     </li>
 *
 *     <li><b>Задачи, требующие возврата к предыдущим состояниям</b>:
 *     <ul>
 *         <li>Примеры: Задача коммивояжера, задача о рюкзаке, головоломки (например, судоку).</li>
 *         <li>Рекурсивные алгоритмы могут быть полезны для перебора всех возмож
 *
 * Рекурсивные алгоритмы могут быть полезны и удобны для решения задач, которые естественно решаются с использованием рекурсии.
 *
 * <ul>
 *     <li><b>Задачи, решаемые методом "разделяй и властвуй"</b>:
 *     <ul>
 *         <li>Примеры: Быстрая сортировка (Quick Sort), сортировка слиянием (Merge Sort).</li>
 *         <li>Эти задачи включают деление проблемы на подпроблемы меньшего размера, решение подпроблем и комбинирование их результатов.</li>
 *     </ul>
 *     </li>
 *
 *     <li><b>Обход структур данных</b>:
 *     <ul>
 *         <li>Примеры: Обход деревьев (дерево решений, двоичное дерево поиска), обход графов.</li>
 *         <li>Рекурсия позволяет естественно и лаконично обходить узлы деревьев или графов.</li>
 *     </ul>
 *     </li>
 *
 *     <li><b>Задачи с повторяющимися подпроблемами</b>:
 *     <ul>
 *         <li>Примеры: Числа Фибоначчи, задачи динамического программирования (если используется мемоизация).</li>
 *         <li>Рекурсия позволяет выразить задачу в виде рекурсивного соотношения.</li>
 *     </ul>
 *     </li>
 *
 *     <li><b>Задачи, требующие возврата к предыдущим состояниям</b>:
 *     <ul>
 *         <li>Примеры: Задача коммивояжера, задача о рюкзаке, головоломки (например, судоку).</li>
 *         <li>Рекурсивные алгоритмы могут быть полезны для перебора всех возможных решений (backtracking).</li>
 *     </ul>
 *     </li>
 *
 *     <li><b>Явно рекурсивные задачи</b>:
 *     <ul>
 *         <li>Примеры: Ханойская башня, рекурсивные математические функции (факториал).</li>
 *         <li>Некоторые задачи естественным образом определяются рекурсивно, и их реализация будет проще и понятнее с использованием рекурсии.</li>
 *     </ul>
 *     </li>
 * </ul>
 *
 * <h3>Преимущества рекурсивных алгоритмов:</h3>
 * <ul>
 *     <li><b>Простота и читаемость</b>: Рекурсивные алгоритмы могут быть проще и понятнее для понимания и реализации.</li>
 *     <li><b>Поддержка сложных структур данных</b>: Рекурсия часто упрощает код для работы со сложными структурами данных, такими как деревья и графы.</li>
 *     <li><b>Естественное выражение решения</b>: Некоторые задачи легче выразить и решить с помощью рекурсии.</li>
 * </ul>
 *
 * <h3>Недостатки рекурсивных алгоритмов:</h3>
 * <ul>
 *     <li><b>Переполнение стека (Stack Overflow)</b>: Рекурсивные алгоритмы используют стек вызовов, что может привести к переполнению стека при глубокой рекурсии.</li>
 *     <li><b>Производительность</b>: Рекурсивные алгоритмы могут быть менее эффективными по времени и памяти, если не оптимизированы (например, отсутствие мемоизации в задачах с повторяющимися подпроблемами).</li>
 *     <li><b>Сложность отладки</b>: Отладка рекурсивных алгоритмов может быть сложнее по сравнению с итеративными.</li>
 * </ul>
 *
 * <h3>Итеративные альтернативы:</h3>
 * Иногда рекурсивные алгоритмы можно заменить на итеративные для улучшения производительности и предотвращения переполнения стека. Например, итеративная версия алгоритма обхода дерева с использованием стека может заменить рекурсивную версию.
 *
 * <p>Выбор между рекурсией и итерацией зависит от конкретной задачи и требований к производительности и читаемости кода.</p>
 */

public class Recursion {

    public static int length(int[] arr){
        if(arr.length == 0){
            return 0;
        }
        return 1 + length(Arrays.copyOfRange(arr, 1, arr.length));
    }

    public static int sum(int[] arr){
        if(arr.length == 0){
            return 0;
        }
        return arr[0] + sum(Arrays.copyOfRange(arr, 1, arr.length));
    }

    public static int searchMax(int @NotNull [] arr){
        if(arr.length == 1){
            return arr[0];
        }
        if(arr.length == 2){
            return Math.max(arr[0], arr[1]);
        }
        int subMax = searchMax(Arrays.copyOfRange(arr, 1, arr.length));
        return Math.max(arr[0], subMax);
    }

    public static int factorial(int num){
        if(num <= 0) {
            throw new IllegalArgumentException("Факториал считается для числа >= 1");
        }
        if (num == 1){
            return 1;
        }
        return num * factorial(--num);
    }
}
