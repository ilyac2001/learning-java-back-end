----------Applicatio Context & Dependency Injection----------
Внедрение зависимостей. Зависимость - связи между объектами (один зависит от другого).
Задача создать объект класса единожды (паттерн Singleton) и внедрить ссылку на объект (созданее объектов вручную, как поле класса) во все классы (встроить в иерархию)
	Фрэймворк Spring - готовое решение (выполняет задачи описаные выше), самому писать - сложно, запутанно, дополнительный код.
зависимости Spring-core и Spring-beans (отвечает за создание объектов) и Spring-context (доступ к классам Spring например ClassPathXmlApplicationContext)

***Applicatio Context***
resurces (помеченная папка) - файлы доступны другим java классам (храница конфигурация Springа .xml .properties)
	фреймворк читает конфигурацию и кладёт их в свой контекст
	данные файлы относятся к классу (хранятся в переменной) classpath
	*в .xml описываются из каких классов надо создать bean
	*в .properties хранятся свойства в формате ключ-значение, к которым можно обращаться через ${}
		для обращения из .xml нужно в .xml написать <context:property-placeholder location="classpath:FileName.properties"/>

bean и объект - схожие вещи. объект, созданный Springом называется бином
	в конфигурации Springа описывается bean какого оъекта требуется создать
    <bean id="testBean"
          class="org.example.TestBean">
        <constructor-arg value="SomeName"/>
    </bean>
	*я создаю контекст, указывая конфигурацию (которое тоже создаю)
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
	*Spring читает .xml и помещает все beans в ApplicationContext
	*после я могу достать bean (объект созданный Springом в перделах контекста)
TestBean tb = context.getBean("testBean", TestBean.class); //передаётся id (описано в конфигурации) и класс
System.out.println(tb.getName());
context.close(); //обязательное действие
p.s.
конфигурацию Springа можно описывать через XML или аннотации Java

***Inversion of Control***
инверсия управления
проблемы:
	сильная зависимость - решение создать интерфейс или абстрктный класс
	слабая зависимость, когда в калссе определяется экземпляр (через интерфейс) - решение создать метод, через который (получается из вне) можно передавать аргумент и определять экземпляр IoC
(Dependency Inversion (Принцип инверсии зависимостей).)
	проблема создания объекта извне для внедрения его (зависимости) в класс - Spring решает проблему Dependency Injection:

IMusic music = music_context.getBean("musicBean", IMusic.class);//экзепляр интерфейса теперь изменяется не здесь, то есть конструкции new...
//можно в файле конфигурации
    <bean id="musicBean"
          class="org.example.DependencyInversion_InversionOfControl.Classic"> //изменение экземпляра!
    </bean>
//остаётся  решить следующую проблему, внедрением зависимости
Player p = new Player(music);

***Dependency Injection***
КОНСТРУКТОР И SETTER
    <bean id="musicBean"
          class="org.example.DependencyInversion_InversionOfControl.Silence">
    </bean>
<!--Dependency Injection-->
    <bean id="playerBean"
          class="org.example.DependencyInversion_InversionOfControl.Player">
        <constructor-arg ref="musicBean"/>
    </bean>
//IMusic music = music_context.getBean("musicBean", IMusic.class); //этот код уже не трубется
//Player p = new Player(music);					   //этот код уже не трубется
Player p = music_context.getBean("playerBean", Player.class); //зависимость определена в конфигурации

аналогично конструктору <constructor-arg, но синтаксис другой:
<property name="music" ref="musicBean"/>
//заменяет код //setMusic(IMusic m){this.music = m};
	название очень важно, Spring ищет Setter, а именно set...Propety(),
	убирает set, слова разделяются маленько буквой, 
	то есть зависимость name="music" - Spring ищет метод setMusic()
	зависимость name="name" - ищет setName();
НО так или иначе class=... вызывает конструктор при создании бина!
	если конструктор с параметрами, то обязательно требуется в конфигурации указать <constructor-arg.../>

ССЫЛКИ И ПРОСТЫЕ ЗНАЧЕНИЯ, ЗНАЧЕНИЯ ИЗ ВНЕШНЕГО ФАЙЛА
-типы данных
	ссылочные: ref="название бина, его id"
	простые:   value="значение", value=${класс.поле} также такие значения можно брать из файла .properties

в .properties хранятся свойства в формате ключ-значение, к которым можно обращаться через ${}
	для обращения из .xml нужно в .xml написать <context:property-placeholder location="classpath:FileName.properties"/>
.player.properties
	Player.value=99
.xml
    <context:property-placeholder location="classpath:player.properties"/>
        <property name="music" ref="musicBean"/>
        <property name="volume" value="${Player.value}"/>

---Жизненный цикл бина---
*Scope, область видимости бинов*
конфигурация scope задаёт то, как Spring будет создавать бины
scope:
	Singleton - по умолчанию, то есть GetBean() возвращал ссылку на один и тот же объект
	Prototype - GetBean() создаёт новый объект (в пределах одного контекста из определения)
	далее в MVC: request, session, global-session

*специальные методы бинов*
жизаненный цикл:
запуск приложения Spring -> запуск Spring контейнера (тот самый контекст) -> создаётся объект бина (конструктор) -> в бин внедряются зависимости -> 
	-> вызывается init-method ->
	-> бин готов к использованиб ->
	-> вызывается указанный destroy-method (не для scope="prorotype") -> остановка приложения Spring
init-method - запуск указанного метода в момент инициализации бина, ресурсов, БД, обращение к внешним файлам
destroy-method- запуск указанного метода в момент в ходе уничтожения, очищение ресурсов, закрытие потоков и доступа к БД
	не вызывается для scope="prorotype"
особенности:
	ЛЮБОЙ модификатор доступа И у КОНСТРУКТОРА в том числе
	эти методы не должны принимать аргументы, ПАДАЕТ во время выполнения, непроверяемое исключение
	возв знач любое, всё равно обработать нелья
	название любое (на удивление для setterов это вадно, см. выше)
	destroy не вызывается для scope="prorotype"
factory-method - запуск указанного метода в момент в момент создания бина
особенности:
	метод должен иметь реализацию фабрики, иначе выбрасывается не проверяемое исключение
	вызывается перед конструкором
	ДАЖЕ если scope="singleton", а в конструкции фабрики new Class(), то всё равно объект будет ОДИН!
---Аннотации---
Альтернатива описанию .xml
например @Component перед классом заменяет .xml
    <bean id="someClass"
          class=".SomeClass">
    </bean>

тогда в конфигурации Spring нужно указать сканирование компонентов 

@Component - пометка для каласса на создание бина
	@Component("id"), если по умолчанию, то название класса с маленькой буквы
@Autowired - Spring автоматически внедряет зависимости
	пометка для полей, методов(пофиг,что не setter, по аннотации spring всё поймёт) и конструкторов, ДАЖЕ private
	сканирует и ищет подходящий бин на место класса или класса реализ. интерфейс
	если не находит выбрасывает непроверяемое исключение
	если неоднозначность, даже нескомпилится
		- решение это аннотация @Qualifier
@Qualifier - указываем id того бина, что хотим внедрить
	аннотация указывается после @Autowired
	@Qualifier("id_nameBean")
	если уточнение в конструкторе, то аннотация указывается перед типом данных аргумента
@Value - задать значение простому типу даннхы из файла .properties
@Scope("prototype") - указывается перед описанием класса, как Component
@PostConstract - init-method
@PreDestroy - destroy-method
	чтобы методы работали нужно добавить зависимости, т.к. данные аннотации были удалены из java11
	<dependency>
	    <groupId>javax.annotation</groupId>
	    <artifactId>javax.annotation-api</artifactId>
	    <version>1.3.2</version>
	</dependency>

*аналог .xml файлу*
Java класс, который можно использовать, как аналог .xml должен иметь аннотации

перед объявлением класса
@Cofiguration - помечает класс, который должен быть испоьзован для конфигурации Spring
	для каждого xml тэга етсь соответствующая аннотация
@ComponentScan("pack") - какие классы требуется сканировать Spring
@ProretySource("classpath:file_name.properties") - аналогично, только подтяивание .properties файла
class ConfigurationSprint(){}

для обращения к контексту
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigurationSprint.class);
//вместо //ClassPathXmlApplicationContext music_context_annotations_xml = new ClassPathXmlApplicationContext("Context.xml");

@Configuration
@ComponentScan("org.example.Annotations")
@PropertySource("classpath:player.properties")
public class ConfigurationSprint_MusicContext {
    @Bean
	//@Scope("prototype") //по желанию, можно определить здесь
    public Classic classic() { //classic - bean id
        return new Classic();
    }
}
	альтернатива создания бина, например вместо @Component - перед объявлением класса
	id определяется аналогично
что касается внедрения зависимостей таким образом, то потребуется в этом java файле создавать bean того класс, в который требуется внедрить зависимость, а не другим способом
----------MVC----------
требуется реализовать model-view-controller, путём пометки классов аннотациями и добавлением html,css,js и конфигурации Spring
уже Springом реализовано: http request приходит на сервер -> сервер его обрабатывает -> передаёт его на SpringMVC -> попадает в DispatcherServlet
DispatcherServlet - входная точка в программу SpringMVC
	Точка входа приложения - то, куда приходит http запрос в наше приложение
	DispatcherServlet находится между http request пользователя и Controller
DispatcherServlet определяет куда будет отправлен запрос, на какой Controller

Зависимости что и к spring core + spring-web, spring-webmvc, thymeleaf-spring6

сервер, например ApathyTomcat, считывает содержимое файла web.xml
задача, чтобы сервер все запросы от пользователя отправлял на DespatherServlet
	как альтернатива .xml можно использовать абстрактный java класс AbstractAnnotationConfigDispatherServletInitializer + добавить зависимость Java Servlet API

в конфигурации .xml Springа нужно указать
    <mvc:annotation-driven/>
	как альтернатива .xml это аннотация для класса конфигурации @EnableWebMvc
и описать 3 бина для работы thymeleaf

***Контроллеры***

@Controller //аннотация, что данный класс является контроллером
public class HelloController {

    @GetMapping("/hello-world") //по такому url будет вызываться метод
    public String sayHello() {
        return "hello_world"; //возвращаем пользователю view, а именно hello_world.html
    }
}

аннотация наследуется от @Component, поэтому ComponentScan работает с аннотацией @Controller также (создаёт Bean из него)
Чаще: 1 метод - 1 url - возвращает строку (название view.html), но можно и json...

Важен Mapping, их 5 - соответсвует какой http запрос должен прийти в этот контроллер
@GetMapping("/hello-world") - по адресу /hello-world обрабатывается Get-запрос
@RequestMapping("/some_name_url") - аннотация класса
	озоначается, что для всех методов класса будут иметь обязательно /some_name_url
	то есть для метода @GetMapping("/hello-world") такого класса будет url - /some_name_url/hello-world

*HTTP*
на сервере работает Spring приложение
клиент и сервер общаются через http-запрос/ответ
структура запроса:
	стартовая строка - метод запроса, адрес, используемый протокол. например: GET /wiki/java HTTP/1.1
	заголовки - их может быть много, например: сервер, браузер, что ожидаем (вернёт html страницу)
	пустая строка
	тело - может быть пустым, передаются доп данные, параметры, файлы. например: k1=v1&k2=v2

GET 	- ничего не меняет на сервере, тело запроса пустое
	параметры нужны для передачи информации от клиента к серверу во время запроса
	параметры передаются в URL
	после знакак ?
	 и только в формате ключ=значение&ключ2=значение2
	знак & разделяет несколько параметров
POST 	- изменяем (добавляем) что-то на сервере (новая учётка, загрузка фото, новый твит...)
	параметры хранятся в теле
	один из заголовков является Content-Type: может быть json, xml...
	передаются ключ=значение, java-объекты, файлы...

структура ответа:
	стартовая строка - используемый протокол, код ответа например: HTTP/1.1 200 ОК
	заголовки - их может быть много, например: сервер, браузер...
		тип контента в теле ответа Content-Type:text/html
	пустая строка
	тело - <h1>Hello world</h1>

статусы ответа:
	1xx: Informational (информационные)
	2xx: Success (успешно)
	3xx: Redirection (перенаправление)
	4xx: Client Error (ошибка клиента)
	5xx: Server Error (ошибка сервера)

*Параметры контроллера*
Получение параметра url:
	в параметре метода указать HttpServletRequest request; String значение = request.getPatameter("ключ");
		в данном случае request хранит множество других данных, а после мы получаем из него параметр
	или в параметре @RequestParam("ключ") String значение
		проще, работаем только с параметром
		!обязывает вводить url с параметров, иначе получение ошибки 400 Bad Request
		//в html можно сделать вот так: <a href="bye?name=some_name">Say bye...</a>
		если хочется избежать такое поведение @RequestParam(value = "name", required = false)
Обращение к модели
модель - контейнер для данных, состояние системы
	доступ через параметр класса Model
и тогда данные можем положить в модель model.addAttribute("ключ", "значение");
досутуп через thymeleaf th:text, чтобы динамически отображать значение <p th:text="${ключ}"></p>
