Чистый код
Важность в мелочах, код должен быть тчательно проработан (то есть слёту не получится предложить, как его улучшить), приятно читаем и понятен другому человеку.
Пресекать бардак нужно сразу. Хорошая метафора, как на рабочем месте у станка.
Устранение дублирования, выполнение одной операции, выразительность, простые абстракции. крч ООП и SOLID
--------------ИМЕНА----------------------------------------------------------------------------------------------------------------------------------------------
их надо давать так, чтобы было понятно что, есть что, избежать неочевидность, не подразумевалось, что читатель знает ответы на очевидные (как может показаться) вопросы
даже однострочные конструкции с константами (волшебными числами) нужно выносить в отдельный метод
if (cell[STATUS_VALUE] == FLAGGED)
	flaggedCells.add(cell);
=>
if (cell.isFlagged())
	flaggedCells.add(cell);

дезынформация - избегать, List - структура данных, или всё-таки какой-то список имён? (которые могут храниться в массиве). 
Длинные и понятные имена, но в них малозаметных различия? - чёрт ногу сломит, человек ленивый и не внимательный.

Неинформативные слова избыточны.
Похожие символы - плохо О-0 l-1.
a1, a2, и что это значит? неочевидно.
klass (ведь class ключевое слово языка)
theZork... the не несёт никакой смысловой нагрузки, а переменная zork уже есть, так не надо (p.s. артиклы a  и the применялись, как например перед приватной переменной ставить символ "_", но о префиксах ниже)

Чем имя NameString лучше Name? Разве имя может быть, скажем, вещественным числом?
При отсутствии жестких именных схем имя moneyAmount не отличается от money, customerInfo не отличается от customer, accountData не отличается от account, а theMessage — от message. 
Записывайте различающиеся имена так, чтобы читатель кода понимал, какой смысл заложен в этих различиях.

миена удобно читать, как книгу, чтобы их имена применять в речи
имена должно быть удобно искать

префиксы не нужны, IDE крутые, языки современные, всё и так понятно + не нужно изменять имя переменной при изменении её типа
Кроме того, люди быстро учатся игнорировать префиксы (и суффиксы), чтобы видеть содержательную часть имени. Чем больше мы читаем код, тем реже заме чаем префиксы. В конечном итоге префикс превращается в невидимый балласт, характерный для старого кода.

имена можно понять из контекста
1. предметной области
2. код - для программистов (паттерны, например)
хорошие префиксы - addrFirstName? addrLastName... но лучше обернуть имена (которые составляют адрес) в класс Address

перегружать тоже не очень хорошо, короткие имена лучше длинных, но если мы не теряем смысл. отсюда необходимость оборачивания в контекст
ещё IDE может высрать огромный список имён, если ты перед каждым вставляешь одно и тоже
MAC URL - понятно, что это адреса. для других случаев создаётся класс Адрес, а потом объект адрес покупателя/аккаунта т.п.
--------------ФУНКЦИИ--------------------------------------------------------------------------------------------------------------------------------------------
1. Должны быть компактны, умещалась в экран ~20 строк.
2. Выполнять только 1 операцию. Для этого:
	На функцию 1 уровень абстракции (что должно быть ясно из имени функции);
	Функцию, невозможно осмысленно разделить на секции;
АРГУМЕНТЫ
Функций с тремя аргументами (тернарных) следует по возможности избегать; 0 аргементов - круто. И читать проще, понимать, тестировать (проверять корректность входных данных).
	нормально, 1 аргумент - проверка некоторого условия, связанного с ним (boolean fileExists("MyFile"))
	нормально, 1 аргумент - обработка его, преобразование и возвращение (InputStream fileOpen("MyFile"))
	нормально, 1 аргумент - событие, когда выходного аргумента нет, но по события программа изменяет состояние системы в зависимости от аргумента
	не нормально, преобразования, в которых вместо возвращаемого значения используется выходной аргумент. В самом деле, вызов StringBuffer transform(StringBuffer in) лучше вызова void transform(StringBuffer out),
Не использовать аргументы ФЛАГИ. Сбивает с толку, если флаг, то уже заведома функция может выполнять две операции.
Количесвто их нужно сокращать, оборачивать в классы и объединять в структуры (как например x, y - Point). НО списки аргументов использовать можно, по сути это 1 аргумент типа List

Входные - понятный, чтобы не приходилось смотреть на сигнатуру. appendFooter(s);??? -> public void appendFooter(StringBuffer report)
Выходные. В общем случае выходных аргументов следует избегать. Если ваша функция должна изменять чье-то состояние, пусть она изменяет состояние своего объектавладельца. report.appendFooter();

ОШИБКИ
Возвращать код ошибки плохо - огромная портянка if-ов получается, можно использовать возврат ошибки.
Но try/catch нужно изолировать, на уровень абстрации, чтобы где-то обработать ошибку, а далее забыть о ней.

try {
	deletePage(page);                             //представь тут на каждую функцию был бы повешен if else...
	registry.deleteReference(page.name);
	configKeys.deleteKey(page.name.makeKey());
}
catch (Exception e) {
	logger.log(e.getMessage());
}

лучше + обработка ошибки - 1 операция, ничего после catch и finaly быть не должно
public void delete(Page page) { //специализируется на обработке ошибки
	try {
		deletePageAndAllReferences(page);
	}
	catch (Exception e) {
		logError(e);
	}
}
private void deletePageAndAllReferences(Page page) throws Exception {
	deletePage(page);
	registry.deleteReference(page.name);
	configKeys.deleteKey(page.name.makeKey());
}
private void logError(Exception e) {
	logger.log(e.getMessage());
}
--------------Switch case----------------------------------------------------------------------------------------------------------------------------------------
Желательно (если без неё не обойтись) скрыть команды в низкоуровневом классе и не дублировать их в коде.
Например, в конструкции в зависимости от типа работника, мы решаем какую ЗП ему платить. 
Проблемы 
1) она велика, а если работники будут добавляться, то и функция будет расти
2) Нарушение принципа открытости/закрытости
3) Нарушение принципа единой ответственности
4) ! В case очень много функций с одинаковой структурой. isPayday(Employee e, Date date) и deliverPay(Employee e, Money pay)...
Решение - полиморфизм.

public Money calculatePay(Employee e)
throws InvalidEmployeeType {
	switch (e.type) {
		case COMMISSIONED:
	return calculateCommissionedPay(e);
		case HOURLY:
	return calculateHourlyPay(e);
		case SALARIED:
	return calculateSalariedPay(e);
		default:
	throw new InvalidEmployeeType(e.type);
	}
}

Решение проблем заключается в том, чтобы похоронить команду
switch в фундаменте АБСТРАКТНОЙ ФАБРИКИ и никому ее не показывать. 
Фабрика использует команду switch для создания соответствующих экземпляров потомков Employee, а вызовы функций calculatePay, isPayDay, deliverPay и т. д. проходят полиморфную передачу через интерфейс Employee.

public abstract class Employee {
	public abstract boolean isPayday();
	public abstract Money calculatePay();
	public abstract void deliverPay(Money pay);
}
-----------------
public interface EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}
-----------------
public class EmployeeFactoryImpl implements EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
		switch (r.type) {
			case COMMISSIONED:
		return new CommissionedEmployee(r) ;
			case HOURLY:
		return new HourlyEmployee(r);
			case SALARIED:
		return new SalariedEmploye(r);
			default:
		throw new InvalidEmployeeType(r.type);
		}
	}
}
-----------КОММЕНТАРИИИ------------------------------------------------------------------------------------------------------------------------------------------
грамотный комментарий - компенсация НЕУДАЧИ (т.к. язык программирования не настолько выразителен)
Нередко задача сводится с созданию функции, которая сообщает то же, что и комментарий, который вы собираетесь написать. 
хорошие (очевидные, краткие, на своём месте):
-ссылка на документ, юридическая информация
-пояснения (например, формат даты, но его можно обернуть в класс, который приводит дату к нужному формату)
-объяснение намерений (почему именно такая логика работы кода, зачем он тут нажен)
-пояснения к библиотеки или коду, который нельзя изменить (нарпимер комментирование возвращаемого значения метода сравнения когда тот возращает 0 или 1), но такой код и комментарий очень тяжело проверить, поэтому он несёт риск!
-предупреждение о последствиях (//этот тест метод выполняется очень долго)
-TODO (доделать на будущее)
// TODO - На данный момент эта функция не используется.
// Ситуация изменится при переходе к отладочной модели.
//например удаления старой ф-ции или предложить кому-то другому поучавствовать в решении проблемы
-усиление
// Вызов trim() очень важен. Он удаляет начальные пробелы...
Правила, говорящие, что каждая функция должна иметь комментарий Javadoc или что каждая переменная должна быть помечена комментарием, — обычная глупость. Такие комментарии только загромождают код, распространяют недо- стоверную информацию и вызывают общую путаницу и дезориентацию
Избавляться от комментариев путём использования переменных, методов и т.п.
Нельзя оставлять закомментированный код!
