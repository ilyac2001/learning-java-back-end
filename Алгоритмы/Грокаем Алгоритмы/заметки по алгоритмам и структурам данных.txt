---------Big O или О большое---------
O() - показывает скорость изменения ЭФФЕКТИВНОСТИ работы алгоритма по скорости/памяти
поэтому константы отбрасываются, например O(n^2)~O(1/2*n^2),
а при n->∞ берётся во внимание функция с самой высокой скоростью роста

Частые (скорость по возрастанию):
O(n!) факториальная (задача о коммивояжере)
O(2^n)
O(n^2) (простые сортировки: пузырьком, вставками, выбором...)
O(n*log_n) (быстрая сортировка)
O(n) линейная (простой перебор)
O(log_n) логирифмический (бинарный поиск)
O(1) - const

-правила (базируются на определении O() - показывает эффективность)
O(n) + O(m) = O(n + m) - для последовательных циклов. При n = m: O(n + m) = O(2n) = O(n)
O(n * m) - для вложенных циклов. При n = m: O(n*n) = O(n^2)
O(n^2 + n) = O(n^2) - неважная сложность


Обычно константа игнорируется, потому что если два алгоритма имеют разное время "О-большое", она роли не играет
Однако в некоторых случаях константа может иметь значение. Один из примеров такого рода - быстрая сортировка и сортировка слиянием. У быстрой сортировки константа меньше, чем у сортировки слиянием, поэтому, несмотря на то Что оба алгоритма характеризуются временем О(п log п), быстрая сортировка работает быстрее. А на практике быстрая сортировка работает быстрее, потому что средний случай встречается намного чаще худшего.
Средний и худший случай - сценарий работы эффективности алгоритма. Имеет место быть, но за частую рассматривается наимболее частый случай - средний (как правило лучший и явлется средним)
---------Структуры данных---------
***массивы и списки***
массив - быстрое чтение O(1), доступ к элементу по индексу. Медленное вставка/удаление
списки - наоборот
