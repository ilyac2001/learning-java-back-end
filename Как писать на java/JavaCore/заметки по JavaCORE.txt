............КЛАССЫ И ООП............
------------пакеты------------
Пакеты соответствуют физической структуре проекта, оргинизация каталогов, в которых находятся исходные файлы проекта
В пакете описываются классы. Всегда есть пакет по умлчанию, где хранятся не определённые классы.
package name;
Пакеты требуется подключать, кроме по умолчанию java.lang (например, String)
Другие пакеты импортируются
import java.name	//import java.* - подключается всё без разбору

Использование двух классов с одним и тем же названием из двух разных пакетов
И если нам надо одновременно использовать два этих класса, то необходимо указывать полный путь к этим классам в пакете:
java.util.Date utilDate = new java.util.Date();
java.sql.Date sqlDate = new java.sql.Date();

Статический импорт
Для этого вместе с директивой import используется модификатор static:
import static java.lang.Math.*;
public class Program { 
    public static void main(String[] args) {
        double result = sqrt(20); //класс Math имеет статический метод
    } 
}
Благодаря операции статического импорта мы можем использовать эти методы без названия класса. Например, писать не Math.sqrt(20), а sqrt(20)
------------модификаторы доступа------------
связаны с доступом из других классов и ПАКЕТОВ
их 4! а не 3, модификатор по умолчанию отличается от public тем, что не доступна видимость другим пакетам
наследникам досутупны все поля и методы (кроме private) базового класса даже если они находятся в другом пакете
------------типы данных------------
существуют примитивы и ссылочные типы данных
var переменная = значение (для определения типа, если не присвоить, то ошибка)
char: хранит одиночный символ в кодировке UTF-16 и занимает 2 байта

static
	память выделяется единоразово на этапе компиляции, явлется общим для всех объектов класса
	может использоваться без создания объекта (класса или ИНТЕРФЕЙСА)
	привязан к классу, поэтому не может быть переопределён
	МОГУТ БЫТЬ ТОЛЬКО ФУНКЦИИ И ПОЛЯ (не классы, если конечно класс не вложенный/внутренний, а значит является полем внешнего класса)!
	значение определяется только в static методах, статическом инициализаторе, не обязательно до компиляции, НЕЛЬЗЯ в конструкторе, т.к. относится к классу, а не к объекту
final
	константа, присвоить значение можно только единожды
	нельзя наследоваться от final класса
	нельзя переопределять final методы
static final - действую все те же правила, НО нельзя использовать статический метод для присвоения значения, оно должно быть установлено в момент её объявления или в статическом блоке инициализации
*Про аргументы функции*
В методы аргументы примитивы передаются по значению
А аргументы ссылки - также, но передаётся копия ссылки на объект, поэтому:
-объект изменяется и изменения видны вне метода
-изменяется ссылка - аналогично примитивам, оригинальная ссылка не изменна

Параметры переменной длины.
String args[]
int ...nums (в данном случает ... обозначается, что кол-во аргументов не обязательное 0, 1... n)
------------классы------------
Статический инициализатор
static{
}
вызывается перед созданием самого первого объекта (до конструктора, а т.к. он статический, то единожды)

Вложенные (nested / внутренние, inner) классы.
-объекты такого класса могут быть созданы ТОЛЬКО внутри внешнего класса
-внутренний (не static!) /внешний класс имеет доступ ко всем полям внешнего/внутреннего класса, в том числе private
-объявить и описать его можно внутри любого контекста (тело метода, цикла...)
-внутренний класс можно объявить, как static, если требуется связь с внешним классом, но НЕ ДОСТУП к его ПОЛЯМ. Также не хранят ссылку на внешний объект, поэтому экономят память

Анонимные классы
-классы без имени, ограниченной функциональности, нет доступа к переменным 
-для создания одноразовых объектов (когда такое нужно, тогда и стоит использовать анонимный класс)
-применяются для быстрого создания (синтаксис такой, что мы передаём в качесве параметра анонимный класс (1 объект, где в этой части кода его создаём и определяем реализацию))
	подклассов
	интерфейсов на месте (см. лямбда)
-например:
	кнопка - у неё есть только и только 1 слушатель событие нажатия ActionListener, кнопка-то одна, переопределяем метод click
	фоновые задачи, использование анон класс для её запуска в новом потоке
	коллекции, Сортировка списка с использованием анонимного класса для Comparator
------------наследование------------
-если конструктор определён родителем, то наследник должен его вызвать super(аргументы конснтруктора родителя)
-наследник может переопределять метод (даже не абстрактный) родителя @Override (аннотация не обязательна), 
	а также может вызвать его super.OverrideMethod(аргументы метода, который переопределяется) если необходимы такие же действия. 
	МОДИФИКАТОР ДОСТУПА должен быть не ниже, чем у родителя (например public родителя, поэтому переопределив нельзя сделать protected или private)
	Возвращаемое значение в методе дочернего класса должно быть того же типа или ПОДТИПОМ возвращаемого значения метода который определен в родительском классе.
	Метод не должен иметь модификатор static.
-наследование и переопределения можно запретить при помощи модификатора final к классу или методу соответственно

        SuperClass.staticMethod(); // вызов статического метода SuperClass
        SubClass.staticMethod();   // вызов статического метода SubClass
        SuperClass obj = new SubClass();
        obj.staticMethod(); // вызов статического метода SuperClass
                               // потому что метод staticMethod() скрыт в SubClass, а не переопределен


Person p = new Employee();
	может вызывать только методы, объявленные в классе Person,
	и переопределенные методы из класса Employee (по сути методы класса родителя только реализация дочернего).
	Однако она не может напрямую вызвать методы, которые уникальны для класса Employee.
Employee e = new Employee();
	может вызывать все методы класса Employee, включая те, которые уникальны для этого класса.
Использовать переменную родительского класса для хранения объектов любого из его дочерних классов.
	Например массив Person[] может хранить объекты как родителя, так и всех наследников.
	Например коллекцию различных подклассов можно обрабатывать одинаковым образом, как родителя.
------------приведение типов------------
-upcasting осуществляется автоматически
-downcasting иначе, от супер класса к подклассу нужно использовать преобразование типов
Object объект = new Наследник(); //
if(объект instanceof Наследника имяОбъектаНаследника){    
    имяОбъектаРодителя.ПереопределённыйМетодНаследника();
}
к интерфейсам применимо тоже самое
но я так и не понял в чём разница между:
Person p = new Person();
и
Object obj = new Person();
(Person)obj.GetName(); //разве что объект без приведения не имеет доступа к уникальным методам класса

отличие от obj.GetClass()
getClass(): Проверяет, что объект является экземпляром точного класса, без учета наследования.
	не приминим к интерфейсам
	использовать, когда нужно узнать класс объекта
instanceof: Проверяет, что объект является экземпляром указанного класса или его подкласса (включая интерфейсы)
	приминим к интефейсам
	когда нужно узнать является ли объект экземпляром указанного класса или его подкласса
------------абстрактные классы------------
-нельзя создать объект, выступает в качестве предоставления функционала для наследников
-если класс имеет хотя бы 1 abstract метод, то он обязан быть абстрактным
-наследники обязаны переопределить все abstract методы
-не абстрактные методы могут иметь релизацию, то есть его можно не переопределять, но использовать его сможет только дочерний (ведь объект родителя создать нельзя, т.к. он абстрактный)
------------интерфейсы------------
-определяет константы и методы
-методы по умолчанию public (могут быть и private читай ниже), константы public static final
-!Если класс НЕ РЕАЛИЗУЕТ какие-то методы интерфейса, 
	то такой класс ДОЛЖЕН БЫТЬ определен как АБСТРАКТНЫЙ, 
	а его НЕ абстрактные КЛАССЫ-НАСЛЕДНИКИ затем ДОЛЖНЫ будут реализовать эти методы.
-нельзя создавать НАПРЯМУЮ объекты интерфейсов, но можно динамически,
	как экземпляр реализующих их классов
	как лямбда выражение, если интерфейс имеет один метод
-множественная реализация интерфейсов (классу придётся реализовывать все методы)
-могут наследоваться (переопределение методов и использование их по умолчанию работает аналогично наследованию классов)
	пример: I1 имеет метод default и является родителем I2. I2 переопределяет этот метод не обозначая его абстрактным. Class имплементирует I2, но метод переопределён, не default, а значит его требуется реализовать 
	(если переопределить как default то зависит от того, какой метод имплементирует класс)
	(если не переопределять, то метод будет доступен классу в реализации I1)
-могут быть вложенными в классы -> всё тоже самое, как и было, только придётся указывать полное имя ИмяКласс.ИмяВложенногоИнтерфейса

//фишка, как с наследниками - Person p = new Employee(); / Employee e = new Employee(); -> см. -наследование-
Printable printable = new Book("Java. Complete Reference", "H. Shildt");
printable.print();      //  Java. Complete Reference (H. Shildt)
printable = new Journal("Foreign Policy");
printable.print();      // Foreign Policy

*модификаторы*
default методы:
	если метод интерфейса объявлен как по умолчанию, то такой метод может иметь реализацию
	если несколько класс имплементирует несколько интерфейсов (множественная реализация), которые имеют одинаковые сигнатуры default методов,
		то он обязан переопределить их (можно вызвать, как у супер-класса)
static методы -> IInterface.staticMethod(); //аналогично статическому методу класса (только тут интрфейс)
private методы: 
	НЕ могут быть default
	по определению используются только внутри интерфейса И ЛОГИЧНО внутри default методов
	не имеет значения static или нет, всё равно

*параметры и возвращаемые значения*
может быть и тем и тем, но нужно понимать, что в качестве объекта выступает экземпляр класса, но типа данных интерфейс
    static Printable read(Printable p){ //в качестве параметра класс имплементирующий интерфейс Printable printable = new Book();
        p.print();
	return new Journal(); //аналогично с типом возвращаемого значения
    }
также интерфейс может быть полем класса

*сравнение*
interface IPrint {
    default void Print(){
        System.out.println("interface, default method");
    }
}
abstract class AClass {
    void Print(){
        System.out.println("abstract class, not abstract method");
    }
}
class PClass{
    void Print(){
        System.out.println("parent class, not override");
    }
}
class Person1 implements IPrint{}
class Person2 extends AClass{}
class Person3 extends PClass{}
public class Main {
    public static void main(String[] args){
        Person1 p1 = new Person1();
        p1.Print();
        Person2 p2 = new Person2();
        p2.Print();
        Person3 p3 = new Person3();
        p3.Print();

        IPrint ip = new Person1();
        ip.Print();
        AClass ap = new Person2();
        ap.Print();
        PClass pp = new PClass();
        pp.Print();
    }
}

*функциональные интерфейсы и лямбда*
Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе.
При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.
interface Operationable{
    int calculate(int x, int y);
}

Operationable operation;
operation = (x,y)->x+y;
int result = operation.calculate(10, 20);
------------перечисления------------
методы:
	values() - возвращает массив всех констант перечисления
	ordinal() - возвращает порядковый номер определенной константы

могут определять константы, поля, методы. конструкторы по умолчанию private и никак иначе => вызывать его можно только внутри самого перечисления
enum Color{
    RED("#FF0000"), BLUE("#0000FF"), GREEN("#00FF00");
    private String code;
    Color(String code){
        this.code = code;
    }
    public String getCode(){ return code;}
}

методы можно определять для отдельных констант
Operation op = Operation.SUM;
op.action(1,2);

enum Operation{
    SUM{
        public int action(int x, int y){ return x + y;}
    },
    SUBTRACT{
        public int action(int x, int y){ return x - y;}
    },
    MULTIPLY{
        public int action(int x, int y){ return x * y;}
    };
    public abstract int action(int x, int y);
}
------------класс Object и его методы------------!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
*Методы класса Object*
-public final Class<?> getClass()
	Возвращает объект класса Class, представляющий тип времени выполнения объекта. Полезно для рефлексии.
-public int hashCode()
	Возвращает хэш-код для объекта. Этот метод используется для хэш-таблиц, таких как те, что предоставляются HashMap.
-public boolean equals(Object obj)
	Определяет, равен ли некоторый другой объект текущему объекту. Стандартная реализация проверяет, являются ли ссылки на объекты одинаковыми.
-protected Object clone() throws CloneNotSupportedException
	Создает и возвращает копию текущего объекта. Класс должен реализовать интерфейс Cloneable, чтобы использовать этот метод.
-public String toString()
	Возвращает строковое представление объекта. Стандартная реализация возвращает строку, состоящую из имени класса и хэш-кода.
-public final void notify()
	Пробуждает один поток, который ждет на мониторе объекта.
-public final void notifyAll()
	Пробуждает все потоки, которые ждут на мониторе объекта.
-public final void wait() + 2 перегрузки по времени ожидания
	Заставляет текущий поток ждать, пока другой поток не вызовет notify() или notifyAll() для этого объекта.
-protected void finalize() throws Throwable
	Вызывается сборщиком мусора, когда нет больше ссылок на объект. Может быть переопределен для освобождения ресурсов.

*Использование и переопределение*
-equals() и hashCode():
	Эти методы часто переопределяются для обеспечения правильной логики сравнения объектов и их корректной работы в коллекциях, таких как HashSet или HashMap.
-toString():
	Полезно переопределить для предоставления строкового представления объекта, что облегчает отладку и логирование.
-clone():
	Реализация интерфейса Cloneable и переопределение метода clone() позволяют создавать поверхностные копии объектов.
-wait(), notify(), notifyAll():
	Используются в многопоточном программировании для координации работы потоков.
-finalize():
	В современных приложениях используется редко, так как управление ресурсами лучше реализовать через try-with-resources и явное закрытие ресурсов.

*контракты equals и hashCode*
-если объекты (equals) равны, то и хэш-коды тоже равны
-если хэш-коды не равны, то и объекты не равны
-если объекты не равны, то хэш-коды могут быть как РАВНЫ, так и НЕ РАВНЫ
-если хэш-коды равны, то объекты могут быть как РАВНЫ, так и НЕ РАВНЫ

стандартная реализация equals сравнивает только ссылки!
для переопределения equals
	сравнить с самим собой (равентсво ссылок): this == obj - true
	сравнить с входным типом данных:	!(obj instaceof/GetClass SomeClass) - false
	приводим к типу и проверяем все поля на равенство с учётом null
нужно обязательно переопределять HashCode
	если все поля класса final, то и значение HashCode вычисляется один раз и навсегда, а значит можно в equals сравнить только коды, а не поля
Зачем?
	если вы переопределяете только equals, но не переопределяете hashCode, объекты, которые должны быть равными (по equals), могут оказаться в разных бакетах в хэш-таблице
------------Обобщения или Generics------------
позволяют создавать классы, интерфейсы и методы, которые работают с типами данных, указанных пользователем при создании экземпляра
	Это обеспечивает типовую безопасность, т.к. тип известен на этапе компилации
	повторное использование кода, т.к. для каждого типа не нужно писать свой класс или перегружать метод
Запреты
	в <> указывается класс! не работает с примитивами
	Нельзя создавать массивы параметризованных типов.
	Нельзя использовать обобщенные типы в статическом контексте.
	Нельзя создавать экземпляры параметризованных типов.
Можно
	несколько универсальных параметров <T, S>
	ограничивать набор типов через классы-наследники, классы имплементирующие некоторый интерфейс, тип данных класса/интефейрса
*Обощённые классы*
class Test<T>{
    private T id;
    Test(T id){
        this.id = id;
    }
    public T GetId() { return id; }
}

Test<String> t1 = new Test<String>(2);
Test<String> t2 = new Test<String>("2");
Test<String> t3 = new Test<String>("id");
t.GetId(); //вызов один и тот же у любого объекта

*Обобщённые интефейсы*
interface ITest<T>{
    T SomeMethod(T param);
}
1. Интерфейс задаёт конкретный тип, класс жёстко привязан в этому типу данных!
Class Test implements ITest<Тип Данных, например String>{
    String SomeMethod(String param){...};
}
2. Если класс обобщённый, то он может позволить себе универсальный параметр, как определено в интерфейсе
Class Test<T> implements ITest<T>{
    T SomeMethod(T param){...};
}

*обобщённые методы*
	также можно поступить и с конструктором
public <T> void print(T[] items){
        for(T item: items){
            System.out.println(item);
        }
    }
}
крч аналогично классу, только тип данны определяется при вызове метода, а не создании объекта

*ограничения обобщений*
ограничить по набору типов:
	Class Test<T extends SomeClassPerent> //доступны только SomeClassPerent или его наследники
	Class Test<T implements ITest>{} //доступны только классы имплементирующие интфейс ITest
	Class Test<T extends SomeClassPerenеt & Itest> //МНОЖЕСТВЕННОЕ ОГРАНИЧЕНИЕ! класс Test может работать только с объектами, которые реализуют интерфейс и явлются наследниками класса-родителя
интерфейс или класс может жёстко привязать в типу данных:
	Class Test implements ITest<String>{} //реализация интерфейса жёстко с типом String
	Class Test<T extends SomeClass<String>>{} //ограничение обобщения к жёсткой привязке к типу

*наследование обобщённых классов*
Обобщенные классы могут участвовать в иерархии наследования: могут наследоваться от других, либо выполнять роль базовых классов.
-базовый обощённый класс
	*класс-наследник должен передавать данные о типе в конструкции базового класса
	class DepositAccount<T> extends Account<T>{}
	*класс-наследник должен может добавлять и использовать какие-то свои параметры типов
	class DepositAccount<T, U> extends Account<T>{}
	*не быть обобщённым, НО тогда придётся определить тип данных!
	class DepositAccount extends Account<Integer>{}
-обобщённый класс наследник, тут использование конструкций базового класса в наследнике проиходит, как обычно
-преобразование обобщённых типов, можно привести объект SomeClass<Integer> к Test<Integer> или SomeClass<String> к Test<String> //SomeClass<T> extends Test<T>
------------record------------
record название (поле1, поле2,...полеN){
    // тело record
}
например:
record Person(String name, int age) { }
-поля являются private final
-имеют метод возвращения значения, например name(), age()
-автоматически будут создаваться методы equals, hashCode и toString
-можно переопределять конструктор:
record Person(String name, int age) { 
    Person{
        if(age<1 || age > 110){
            age = 18;
        }
    }
}
или
record Person(String name, int age) { 
    Person(String firstName, String lastName, int age){ //НО ОБЯЗАТЕЛЬНО НУЖНО КАНОНИЧЕСКИЙ КОНСТРУКТОР
        this(firstName + " " + lastName, age);
    }
}

record - канониченый конструктор, тоже самое что и ниже, но кода меньше:
class Person {
    private final String name;
    private final int age;
 
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
 
    String name() { return name; }
    int age() { return age; }
 
    public boolean equals(Object o) {
        if (!(o instanceof Person)) return false;
        Person other = (Person) o;
        return other.name == name && other.age == age;
    }
 
    public int hashCode() {
        return Objects.hash(name, age);
    }
 
    public String toString() {
        return String.format("Person[name=%s, age=%d]", name, age);
    }
}
------------Исключения------------
Базовым классом для всех исключений является класс Throwable. От него уже наследуются два класса: Error и Exception. Все остальные классы являются производными от этих двух классов.
https://metanit.com/java/tutorial/4.2.php
-Проверяемые исключения являются подклассами Exception (например: IOException, SQLException, ClassNotFoundException...)
	компилятор требует, чтобы такие методы обрабатывал программист
	Обычно используются для указания на условия, которые могут быть восстановлены или обработаны программой (например, отсутствие файла)
-Непроверяемые исключения (например: NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException... тут же и деление на 0 например)
	являются подклассами RuntimeException (который подкласс Exception)
	компилятор не требует от программиста обработки этих исключений
	Обычно используются для указания на программные ошибки, которые, как правило, не могут быть восстановлены (например, деление на ноль).
Методы класса Exeption:
-Метод getMessage() возвращает сообщение об исключении
-Метод getStackTrace() возвращает массив, содержащий трассировку стека исключения
-Метод printStackTrace() отображает трассировку стека

*Свои классы-исключения*
Пример:
-Здесь для определения ошибки, связанной с вычислением факториала, определен класс FactorialException, 
который наследуется от Exception и 
который содержит всю информацию о вычислении. 
В конструкторе FactorialException в конструктор базового класса Exception передается сообщение об ошибке:  super(message). 
Кроме того, отдельное поле предназначено для хранения числа, факториал которого вычисляется.
-Для генерации исключения в методе вычисления факториала выбрасывается исключение с помощью оператора throw: throw new FactorialException("Число не может быть меньше 1", num). 
Кроме того, так как это исключение не обрабатывается с помощью try..catch, то мы передаем обработку вызывающему методу, используя оператор throws: public static int getFactorial(int num) throws FactorialException

*про try-catch*
может быть несколько блоков catch. Если у нас возникает исключение определенного типа, то оно переходит к соответствующему блоку catch.
finally выполняется всегда независимо от того, было вызвано исплючение или нет
try-with-resourses
	try(определение экземпляра РЕСУРСА (потока), который релизует интерфейс AutoCloseable;
		их может быть несколько через ";"){}
	catch(IOException ex){}
	//в finally не требуется закрывать его, закроется автоматически
............КОЛЛЕКЦИИ............
пакете java.util
https://metanit.com/java/tutorial/5.1.php
Iterable
|
|--Collection
    |
    |-- List
    |    +-- ArrayList	на основе массива
    |    +-- LinkedList	на основе двухсвязанного списка
    |    +-- Vector	как ArrayList но медленный НО потокобезопасный (CopyOnWriteArrayList если требуется потокобезопасность)
    |         +-- Stack	предпочтительней использовать Deque
    |
    |-- Set	в отличие от List хранит уникальные значения + не имеет определённого порядка (например нет метода get(int index))
    |   | +-- HashSet
    |   | +-- LinkedHashSet
    |   | +-- TreeSet
    |	|
    |   |--SortedSet 		обеспечивая методы для доступа к элементам в отсортированном порядке по ключу
    |      |--NavigableSet	позволяет извлекать элементы на основании их значений. поиск ближайшего элемента к заданному значению, получение первого и последнего элемента, а также получение подмножества элементов в определенном диапазоне значений.
    |
    |-- Queue	очередь
         | +-- PriorityQueue	не гарантирует строгий порядок элементов в порядке FIFO, но обеспечивает их отсортированность на основе их приоритета
         | +-- ArrayDeque	может использоваться как стэк и как очередь (в том числе двухстороняя)
         | +-- LinkedList
         |
         |--- Deque	двунаправленная очередь
              +-- ArrayDeque
              +-- LinkedList
Map	ключ(уникален)-значение (перебор коллекции Set<Map.Entry<K, V>> entrySet())
| +-- HashMap		не гарантирует порядок элементов
| +-- LinkedHashMap	сохраняет порядок вставки
| +-- TreeMap		хранит по отсортированному КЛЮЧУ или порядку заданному компаратором
|
|--SortedMap
   |--NavigableMap

*Comparable и Comparator*
При использовании своих классов, например TreeSet, не знает, как сравнивать такие объекты, поэтому
TreeSet<MyClass> objs = new TreeSet<MyClass>();
objs.add(new MyClass());
При выполнении этого кода мы столкнемся с ошибкой, которая скажет, что объект Person не может быть преобразован к типу java.lang.Comparable.

-Comparable
чтобы такие объекты можно было сранивать и сортировать, они должны реализовывать интерфейс Comparatable<E>
class MyClass implements Comparable<MyClass>{
	...
	public int compareTo(MyClass obj){	//метод int compareTo(E item) сравнивает текущий объект с объектом, переданным в качестве параметра
		return this.поле_например_name.compareTo(obj.значение_поля_например_getName());	//Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.
	// return this.str.length()-obj.getStr().length(); как вариант по длине слова сравнивать
	}
}

-Comparator
Однако перед нами может возникнуть проблема, что если разработчик не реализовал в своем классе, который мы хотим использовать, интерфейс Comparable, либо реализовал, но нас не устраивает его функциональность, и мы хотим ее переопределить? На этот случай есть еще более гибкий способ, предполагающий применение интерфейса Comparator<E>.
Тогда пишем свой класс компоратор, например class SomeClass_SomeField_Comparator implements Comparator<SomeClass>{}
Интерфейс Comparator содержит ряд методов, ключевым из которых является метод compare():
работает аналогично compareTo, но сигнатура public int compare(SomeClass obj1, SomeClass obj2){ return *некоторая логика вычисления числа <>=0* }

-Цепочки компараторов, thenComparing()
если хочется отсортировать по нескольким полям, то
Интерфейс компаратора определяет специальный метод по умолчанию thenComparing, который позволяет использовать цепочки компараторов для сортировки набора:
Comparator<SomeClass> obj_comp = new SomeClass_SomeField1_Comparator().thenComparing(new SomeClass_SomeField2_Comparator());

*Итераторы*
public interface Iterator <E>{ //ListIterator расширяет функционал, этот интерфейс реализует Collection и Map
    E next();
    boolean hasNext();
    void remove();
}
Итератор в Java — это объект, который позволяет перебирать элементы коллекции (например, List, Set, Map). Итератор предоставляет методы для упорядоченного прохода по коллекции без необходимости знать внутреннюю структуру коллекции.
Основные интерфейсы итераторов

Iterator: Предоставляет методы для перебора элементов коллекции в одном направлении (вперёд).
ListIterator: Расширяет Iterator и предоставляет дополнительные методы для перебора списка в обоих направлениях (вперёд и назад), а также для изменения списка во время итерации.

-Методы интерфейса Iterator
boolean hasNext(): Возвращает true, если в коллекции есть следующий элемент.
E next(): Возвращает следующий элемент коллекции и перемещает курсор на одну позицию вперёд.
void remove(): Удаляет последний элемент, возвращённый итератором. Этот метод можно вызывать только один раз за каждый вызов next().
Методы интерфейса ListIterator
-ListIterator наследует методы Iterator и добавляет свои:
boolean hasPrevious(): Возвращает true, если в списке есть предыдущий элемент.
E previous(): Возвращает предыдущий элемент списка и перемещает курсор на одну позицию назад.
int nextIndex(): Возвращает индекс элемента, который будет возвращён следующим вызовом next().
int previousIndex(): Возвращает индекс элемента, который будет возвращён следующим вызовом previous().
void set(E e): Заменяет последний элемент, возвращённый вызовом next() или previous(), на указанный элемент.
void add(E e): Вставляет указанный элемент в список. Элемент будет вставлен перед элементом, который будет возвращён следующим вызовом next().
............ПОТОКИ............
*база*
пакет java.io
поток - некоторая обстракция, которая используется для чтения/закписи информации
связанным с реальным физическим устройством (файлы, сокеты, консоль...)

В основе всех классов, УПРАВЛЯЮЩИМИ ПОТОМ БАЙТОВ, находятся два абстрактных класса:
-InputStream, OutputStream
	наследники: File, Buffer(ускоряет работу, меньше обращается к потоку), ByteArray, Filter, Data(работает с примитивами), Object(для сериализации объектов), Print(для печати данных)
Для работы с ПОТОКАМИ СИМВОЛОВ используют абстрактные классы:
-Reader, Writer
	наследники: File, Buffer, Char, Filter

основное, что можно делать с потоком байт:
	узнать сколько доступно для чтения/записи
	закрыть (кроме потока байт) выбрасывает throws IOException (см. -Исключения- try-with-resourses)
	прочитать (если не прочитано, пусто, то вернёт -1)
	пропустить
	записать (или очистить и записать всё содержикоме)

*работа с потоками*
try(FileInputStream fin=new FileInputStream("notes.txt");
	FileOutputStream fout=new FileOutputStream("notes_new.txt"))
        {
            byte[] buffer = new byte[256]; 
            int count;
            while((count=fin.read(buffer))!=-1){
                fout.write(buffer);
            }
        }
        catch(IOException ex){
            System.out.println(ex.getMessage());
        }

writeTo - можем вывести массив байт в другой поток
ByteArrayOutputStream baos = new ByteArrayOutputStream();
...
try{ baos.write(buffer); }
...
try(FileOutputStream fos = new FileOutputStream("hello.txt")){     
    baos.writeTo(fos);}
...

PrintStream(OutputStream outputStream) - класс, который используется для записи информации в поток вывода
try(FileOutputStream fos=new FileOutputStream("C://SomeDir//notes3.txt");
    PrintStream printStream = new PrintStream(fos)){
	printStream.println("записали в файл эту строку");}
...

или
try(PrintStream printStream = new PrintStream("file.txt")){
            printStream.print("Hello World!");
//как и любой поток вывода и наследник класса OutputStream он имеет метод write
            String str = "write in file";
            byte[] bytes = str.getBytes();
            printStream.write(bytes);
}

Cериализовать можно только те объекты, которые реализуют интерфейс Serializable. 
Этот интерфейс не определяет никаких методов, просто он служит указателем системе, что объект, реализующий его, может быть сериализован.
class Person implements Serializable{
 Person(String n, int a, double h, boolean m){...}
}
try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.dat"))){
	Person p = new Person("Sam", 33, 178, true);
	oos.writeObject(p);
	Person p2 = (Person)ois.readObject();}
-Исключение данных из сериализации
По умолчанию сериализуются все переменные объекта. Однако, возможно, мы хотим, чтобы некоторые поля были исключены из сериализации. 
Для этого они должны быть объявлены с модификатором transient. Например, исключим из сериализации объекта Person переменные height и married:
 private String name;
 private int age;
 private transient double height;
 private transient boolean married;

*Класс File*
не работает напрямую с потоками, управляет информацией о файлах И каталогах
https://metanit.com/java/tutorial/6.11.php
// создаем объект File для каталога
File dir1 = new File("C://SomeDir");
// создаем объекты для файлов, которые находятся в каталоге
File file1 = new File("C://SomeDir", "Hello.txt");
File file2 = new File(dir1, "Hello2.txt");
Создать, удалить, проверить существование, вернуть путь, имя файла или род. каталога, размер, время...

*Класс Console*
Console console = System.console();
работает с System.in System.out
flush(): выводит на консоль все данные из буфера
format(): выводит на консоль строку с использованием форматирования
printf(): выводит на консоль строку с использованием форматирования (фактически то же самое, что и предыдущий метод)
String readLine(): считывает с консоли введенную пользователем строку
char[] readPassword(): считывает с консоли введенную пользователем строку, при этом символы строки не отображаются на консоли

 Console console = System.console();
        if(console!=null){
            String login = console.readLine("Введите логин:");
	}

*ZIP*
в пакете java.util.zip определены два класса - ZipInputStream и ZipOutputStream
https://metanit.com/java/tutorial/6.12.php
............STRING............
Объекты String являются неизменяемыми, поэтому все операции, которые изменяют строки, фактически приводят к созданию новой строки, 
что сказывается на производительности приложения. Для решения этой проблемы, чтобы работа со строками проходила с меньшими издержками в Java были добавлены классы StringBuffer и StringBuilder. По сути они напоминает расширяемую строку, которую можно изменять без ущерба для производительности.
Эти классы похожи, практически двойники, они имеют одинаковые конструкторы, одни и те же методы, которые одинаково используются. Единственное их различие состоит в том, что класс StringBuffer синхронизированный и потокобезопасный. То есть класс StringBuffer удобнее использовать в многопоточных приложениях, где объект данного класса может меняться в различных потоках. Если же речь о многопоточных приложениях не идет, то лучше использовать класс StringBuilder, который не потокобезопасный, но при этом работает быстрее, чем StringBuffer в однопоточных приложениях.
При всех операциях со строками StringBuffer / StringBuilder перераспределяет выделенную память. И чтобы избежать слишком частого перераспределения памяти, StringBuffer/StringBuilder заранее резервирует некоторую область памяти, которая может использоваться. Конструктор без параметров резервирует в памяти место для 16 символов. Но это значение можно изменить в конструкторе.
С помощью метода capacity() мы можем получить количество символов, для которых зарезервирована память. А с помощью метода ensureCapacity() изменить минимальную емкость буфера символов. Однако финальная емкость может отличаться в большую сторону. Дело в том, что в целях повышения эффективности Java может дополнительно выделять память.
https://metanit.com/java/tutorial/7.4.php - регулярные выражения (для парсинга, обработки строк, создание шаболнов для строки и подстроки)
*пул строк*
String str1 = "Hello";
String str2 = "Hello"; //строка создается с использованием литерала, то JVM сначала проверяет, есть ли уже такая строка в пуле. Если есть, то возвращает ссылку на существующую строку.
System.out.println(str1 == str2);  // true, обе строки указывают на один объект в пуле строк

String str3 = new String("Hello"); //new всегда создаёт новую ссылку на объект, поэтому неважно есть такая строка в пуле строк или нет
System.out.println(str1 == str3);  // false, str3 указывает на новый объект в Heap

str3 = str3.intern();	//Метод intern используется для принудительного добавления строки в пул строк. Если строка с таким же значением уже есть в пуле, то возвращается ссылка на эту строку, иначе строка добавляется в пул.
System.out.println(str1 == str3);  // true, str4 теперь указывает на строку в пуле строк

Из-за неизменяемости строк в Java, любая операция, которая кажется изменяющей строку, на самом деле создает новую строку.
............ЛЯМБДА............
Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе.
При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.
interface Operationable{
    int calculate(int x, int y);
}
Operationable operation = (x,y)->x+y; 
	такая запись аналогична созданию анонимного класса c методом, который является экземпляром интерфейса
	без параметров ()->1+2
	с одиним параметром n->n*n
	можно и не возвращать ничего s->System.out.println(s);//interface Printable{void print(String s);}
	блок кода ()->{};
	использование Generic, но лямбда обобщать нельзя, но можно сделать функциональный интефейс обобщённым, и типизировать его объект 
		Operationable<String> operation = (x, y)-> x + y; //interface Operationable<T>{T calculate(T x, T y);}
int result = operation.calculate(10, 20);
/*
Operationable operation1 = (int x, int y)-> x + y;
Operationable operation2 = (int x, int y)-> x * y;
*/

когда использовать? (чем-то похоже на использование анонимных классов)
-Выполнение кода отдельном потоке
-Выполнение одного и того же кода несколько раз
-Выполнение кода в результате какого-то события
-Выполнение кода только в том случае, когда он действительно необходим и если он необходим

также лямбду можно передавать в качестве параметра в методы
	Expression func = (n)-> n%2==0;
	private static int sum (int[] numbers, Expression func){...func.isEqual(i)...}
в качестве параметра можно передавать и ссылки на методы (в том числе и не static)
	тогда метод должен ПРИНИМАТЬ параметр типа ФУКНЦИОНАЛЬНОГО ИНТЕРФЕЙСА
	а СИГНАТУРА передаваемого метода должна СОВПАДАТЬ с сигнатурой функц интер
		interface Expression{boolean isEven();}
		private static int sum (int[] numbers, Expression func){...}
		class ExpressionHelper(){boolean isEven(){...}}
		sum(nums, ExpressionHelper::isEven) //если static то КЛАСС::метод, иначе ОБЪЕКТ::метод
можно возвращать лямбдку, только тип возвращаемого значения - функциональный интерфейс
	interface Operation{int execute(int x, int y);}
	Operation func = action();
	private static Operation action(){return (x,y)->x+y;}

встроенные функциональные интерфейсы, в пакете java.util.function эти интерфейсы уже описаны
Predicate<T>		- сигнатура (проверяет соблюдение некоторого условия): boolean test(T t); определение экземпляра: Predicate<Integer> isPositive = x -> x > 0; использование: is.Positive.test(1) //true
Consumer<T>		- void accept(T t); x-> System.out.print("ничего не возвращает, принимает " + x);
Function<T,R>		- R apply(T t); Function<Integer, String> convert = x->String.valueOf(x) + " - теперь строка"
UnaryOperator<T>	- T apply(T t); x->x^x;
BinaryOperator<T>	- T apply(T t1, T t2); (x, y) -> x*y;
//public interface Supplier<T> {T get();}
Supplier<User> userFactory = ()->{   
            Scanner in = new Scanner(System.in);
            System.out.println("Введите имя: ");
            String name = in.nextLine();
            return new User(name);
        };
 User user1 = userFactory.get();
............МНОГОПОТОЧНОСТЬ............
------------класс Thread------------
чтобы создать поток, нужно создать объект этого класса (создать или получить текущий поток)
у потока есть имя, приоритет (от 1 до 10 у main - 5), активность, его можно прервать, ожидать завершения, определить точку входа в поток, приостановить, запустить

поток может замедлить работу приложения
каждый поток создаёт собственный стек в памяти
в системе может быть ограничение на кол-во потоков

*создание, выполнение, закрытие потока*
!В Java, поток может быть запущен только один раз. После завершения его невозможно запустить снова.
Для создания нового потока мы можем создать новый класс, 
	либо наследуя его от класса Thread, 
	либо реализуя в классе интерфейс Runnable.
class JThread extends Thread {      
    JThread(String name){
        super(name);}
... создание экземпляра этого класс

class MyThread implements Runnable {
	переопределить метод run() Runnable - функциональный интерфейс
... создание экземпляра класса new Thread(new MyTread(), "name")

Runnable r = ()->{...} //лямбда - экземпляр интерфейса, реализация метода run()
Thread myThread = new Thread(r,"MyThread");
//ну или Thread myThread = new Thread( ()->{}, "ThreadName" );
myThread.start();

1 метод - 1 поток - 1 объект
Если у вас есть несколько методов, которые должны выполняться в отдельных потоках, вам нужно создать столько объектов Thread, сколько методов вы хотите запустить параллельно. Каждый такой объект будет ассоциироваться с одним объектом, реализующим Runnable или наследующим Thread.

run() определяет точку входа, start() запускат, конструктор super(name)
как правила main должен закрываться последним, поэтому другие потоки надо ожидать join()
sleep() - статический метод класса Thread работает с тем потоком, где был вызван, как и currentThread
interrupt() - 
	возвращает true если можно  завершить поток, иначе false
	НЕ ЗАВЕРШАЕТ поток, а только ФЛАГ, что мы НАМЕРЕНЫ завершить поток (флаг = true)
	метод isInterrupted() класса Thread возвращает значение ФЛАГА, то есть по нему можно проверять нужно закрывать поток или нет
	если реализация через интерфейс - while(!Thread.currentThread().isInterrupted()){...} где-то t.interrupt(); isInterrupted в этот момент начнёт возвращать true
	или понять, что поток хотят прервать можно по исключению InterruptedException
исключение InterruptedException выбрасывается
	Когда поток, находящийся в состоянии ожидания (sleep, wait, join...) был прерван - другой поток вызывает метод interrupt() для этого потока
class MyThread extends Thread {
    @Override
    public void run() {
        try {
            while (!isInterrupted()) {
                System.out.println(Thread.currentThread().getName() + " is running");
                Thread.sleep(500); // Исключение выбросится, если поток прервут здесь
            }
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + " was interrupted during sleep");
        }
        System.out.println(Thread.currentThread().getName() + " is finishing");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();

        try {
            Thread.sleep(2000); // Подождать 2 секунды перед прерыванием t1
            t1.interrupt(); // Прервать поток t1
            t1.join(); // Ждать завершения t1, возможно выброс InterruptedException, если основной поток будет прерван
        } catch (InterruptedException e) {
            System.out.println("Main thread was interrupted during join");
        }

        System.out.println("Main thread finished");
    }
}
------------синхронизация потоков------------
еслли потоки будут единовременно обращаться к одному и тому же ресурсу, то поеведение не предсказуемо

*через блокировки*
synchronized
Этот оператор предваряет блок кода или метод, который подлежит синхронизации
synchronized(obj){} //не доступны примитивы
synchronized void increment(){}
иными словами ПОТОК СИНХРАНИЗИРУЕТСЯ НА ОБЪЕКТЕ ИЛИ МЕТОДЕ
поток не может обратиться к ресурсу пока он используется (метод не завершит свою работу) другим потоком
пока synchronized метод ВЫПОЛНЯЕТСЯ он владеет МОНИТОРОМ, конец выполнения или wait - монитор освободился, другой поток (synchronized метод) пытается им завладеть

Блокировки. ReentrantLock
Вначале поток пытается получить доступ к общему ресурсу. 
Если он свободен, то на него накладывает блокировку. После завершения работы блокировка с общего ресурса снимается. 
Если же ресурс не свободен и на него уже наложена блокировка, то поток ожидает, пока эта блокировка не будет снята.
Для работы с блокировками используется класс ReentrantLock. Данный класс реализует интерфейс Lock.
	void lock(): ожидает, пока не будет получена блокировка
	void lockInterruptibly() throws InterruptedException: ожидает, пока не будет получена блокировка, если поток не прерван
	boolean tryLock(): пытается получить блокировку, если блокировка получена, то возвращает true. Если блокировка не получена, то возвращает false. В отличие от метода lock() не ожидает получения блокировки, если она недоступна
	void unlock(): снимает блокировку
	Condition newCondition(): возвращает объект Condition, который связан с текущей блокировкой

*через ограничение к ресурсам*
методы класса Object
должны вызываться из синхронизированного контекста (иначе это приведет к выбросу исключения IllegalMonitorStateException), независимо от того, какой поток их вызывает
wait()		Ожидает до тех пор, пока другой поток не вызовет notify() или notifyAll(). ОСВОБОЖДАЕТ МОНИТОР!
		+перегрузки по времени ожидания
notifay()	Метод notify() возобновляет выполнение одного из потоков (после того, как как монитор освободится), который ранее вызвал метод wait() на том же объекте. 
		Если несколько потоков ожидают на одном объекте, один из них будет случайным образом выбран для возобновления.
notifayAll()

семафоры
представлены классом Semaphore(int permits) +перегрузка Semaphore(int permits, boolean fair)
	использует счётчик (количество доступных разрешений) +очередность/неопределённость получения доступа:
	-может быть как бинарным (разрешающий доступ одному потоку одновременно)
	-так и счетным (разрешающий доступ определенному количеству потоков)
методы Semaphore:
	acquire(): захватывает разрешение, счётчик--, блокирует поток, если разрешений нет (счётчик == 0)
	release(): освобождает разрешение,  счётчик++. лучше выполнять в блоке finally
используются не в synchronized методах, до захвата разрешения (блокировки) методом acquire() потоки могут работать параллельно

*через обмен данными между потоками*
Класс Exchanger предназначен для обмена данными между потоками
V exchange(V x) throws InterruptedException
V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException
x - представляет буффер данных (записываются при вызове), который общий для всех, кто владеет ссылкой на объект Exchanger
Обеспечивает синхронизацию между двумя потоками
	Один поток вызывает метод exchange() и ЖДЁТ,
	ПОКА другой поток не ВЫЗОВЕТ этот метод для обмена данными.

Класс Phaser
Позволяет разбить выполнение программы на несколько фаз, синхронизируя потоки на каждой фазе.
Каждый поток может узнать текущую фазу, завершить её и перейти к следующей.
Инициализация фазера: Phaser phaser = new Phaser(); создаёт фазер без зарегистрированных участников.
Регистрация потоков: Каждый поток регистрируется в фазере при создании.
Фазы: Каждый поток выполняет фазы. Метод arriveAndAwaitAdvance() используется для ожидания завершения фазы всеми потоками.
	Как только все участники завершат текущую фазу, Phaser продвигается к следующей фазе.
Дерегистрация: После завершения всех фаз поток дерегистрируется из фазера с помощью arriveAndDeregister().
............СТРИМЫ............
Stream API связан с понятием
поток данных - канал передачи данных из файлов, массивов, коллекций...
int[] numbers = {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5};
int count=0;
for(int i:numbers){
             
    if(i > 0) count++;
}
System.out.println(count);

а теперь с стримами:
long count = IntStream.of(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5).filter(w -> w > 0).count();
System.out.println(count);

представляет собой цепочку методов
операции с потоками бывают
	промежуточными - возвращают трансформированный поток, как .filter()
	терминальными - возвращают конкретный результат, после НЕЛЬЗЯ применять промежуточные операции
операции с потоками очень похожи на операции с коллекциями НО
	Потоки не хранят элементы
	Операции с потоками не изменяют источника данных
	Для потоков характерно отложенное выполнение. То есть выполнение всех операций с потоком происходит лишь тогда, когда выполняется терминальная операция и возвращается конкретный результат, а не новый поток.

также потоки можно 
	работать с результатом тернальных операций - объект Optional<T>
	перобразовывать в коллекции
		Map, Set, List
		группировать и работать с резульатом группировки
	запускать потоки параллельно (вычисления внутри потока см. ниже)

*создание*
жизненный цикл потока проходит следующие три стадии:
	Создание потока //объект_коллекции.stream() - олучаем поток, который использует данные из списка объект_коллекции, stream() - метод интерфейса Collection, который  реализуется всеми классами коллекций
	Применение к потоку ряда промежуточных операций
	Применение к потоку терминальной операции и получение результата - далее невозможно применить операции к потоку
Stream<String> citiesStream = Arrays.stream(new String[]{"Париж", "Лондон", "Мадрид"}) ;
IntStream intStream = Arrays.stream(new int[]{1,2,4,5,7}); //аналогично для Long и Double
Stream<String> s =Stream.of( T ...values );

*операции*
-промежуточные:
s.forEach(System.out::println); - представляет действие, выполняемое для каждого элемента набора
s.filter(n -> n > 0);		-  принимает объект типа Predicate<T> (см. лямбда), оставляет элементы, что соответвуют условию
s.takeWhile(n -> n < 0)		-  пока соответсвует условию, после ЗАВЕРШАЕТ работу
dropWhile			-  пропускает те, что не соответвуют
s.map(p-> p.getName())		-  принимает Function<T,R>
	s.map(p-> "название: " + p.getName() + " цена: " + p.getPrice())
	s.flatMap(p->Stream.of(
            String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()),
            String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice() - (int)(p.getPrice()*0.1))
s.sorted()			-  сортирует по возрастанию
	подходит только для сортировки объектов, что реализуют интерфейс Comparable
	если не реализуют, то можно использовать перегрузку s.sorted(new SomeClassComparator())
Stream.concat(people1, people2)	-  объединяет элементы ПОТОКОВ
s.distinct() 			-  возвращает только уникальные элементы в виде потока
s.skip(long  n)			-  пропускает поток некоторого числа элементов с начала и возвращает остальное
s.limit(long n)			-  возвращает поток некоторого число элементов с начала
-терминальные:
s.forEach(s->System.out.println(s)); или .forEach(System.out::println()); - применяет операцию к каждому элементу потока
s.count()	- возвращает количество элементов в потоке данных
s.findFirst()	- извлекает из потока первый элемент
s.findAny()	- извлекает случайный объект из потока
boolean allMatch(Predicate<? super T> predicate): возвращает true, если все элементы потока удовлетворяют условию в предикате
boolean anyMatch(Predicate<? super T> predicate): возвращает true, если хоть один элемент потока удовлетворяют условию в предикате
boolean noneMatch(Predicate<? super T> predicate): возвращает true, если ни один из элементов в потоке не удовлетворяет условию в предикате
.min(Integer::compare); .max(Integer::compare); - возвращают минимальный и максимальный соответсвенно
	Optional<T> min(Comparator<? super T> comparator)
	Optional<T> max(Comparator<? super T> comparator)
	объект обязан реализовывать интерфейс Comparable
Optional<T> reduce(BinaryOperator<T> accumulator) - reduce выполняет терминальные операции сведения, возвращая некоторое значение
	Optional<Integer> result = numbersStream.reduce((x,y)->x*y);
	Optional<String> sentence = wordsStream.reduce((x,y)->x + " " + y);

типы данных и методы для работы с терминальными операциями:
Ряд операций сведения, такие как min, max, reduce, возвращают объект Optional<T>. 
Этот объект фактически обертывает результат операции. 
После выполнения операции с помощью метода get() объекта Optional мы можем получить его значение
если пустой, то get выкенет исключение, чтобы избежать
isPresent(). Он возврашает true, если значение присутствует в Optional, и false, если значение отсутствует
	Optional<Integer> min = numbers.stream().min(Integer::compare);
	if(min.isPresent()){}
Метод orElse() позволяет определить альтернативное значение, которое будет возвращаться, если Optional не получит из потока какого-нибудь значения
	//списко пустой, вернёт -1
	Optional<Integer> min = numbers.stream().min(Integer::compare);
	System.out.println(min.orElse(-1));
Метод orElseGet() позволяет задать функцию, которая будет возвращать значение по умолчанию
orElseThrow позволяет сгенерировать исключение, если Optional не содержит значения
Метод ifPresent() определяет действия со значением в Optional, если значение имеется
Метод ifPresentOrElse() позволяет определить альтернативную логику на случай, если значение в Optional отсутствует

*collect преобразование потока к коллекции*
toList(), toSet(), toMap()
 List<String> filteredPhones = phones.stream()
                .collect(Collectors.toList());
//аналогично для Set
для Map надо задавать ключ-значение
Map<String, Integer> phones = phoneStream
            .collect(Collectors.toMap(p->p.getName(), t->t.getPrice()));
у collect есть перегрузка
ArrayList<String> filteredPhones = phones.filter(s->s.length()<12)
            .collect(
                ()->new ArrayList<String>(), // создаем ArrayList
                (list, item)->list.add(item), // добавляем в список элемент
                (list1, list2)-> list1.addAll(list2)); // добавляем в список другой список

группировка
Map<String, List<Phone>> phonesByCompany = phoneStream.collect(
                Collectors.groupingBy(Phone::getCompany));
Collectors.groupingBy(), которая с помощью выражения Phone::getCompany группирует объекты по компании. 
В итоге будет создан объект Map, в котором ключами являются названия компаний, а значениями - список связанных с компаниями телефонов
Map<Boolean, List<Phone>> phonesByCompany = phoneStream.collect(
                Collectors.partitioningBy(p->p.getCompany()=="Apple"));
Collectors.partitioningBy() группирует по соответствует ли элемент определенному условию.
группируя можно
	считать кол-во элементов
	суммировать
	искать минимальное/максимальное
	...

*параллельные потоки*
надо вызвать у объекта Stream метод parallel или parallelStream()
Чтобы сделать обычный последовательный поток параллельным
Затем с помощью метода colletion_name.parallelStream() для списка создается параллельный поток.
однако теперь порядок, в котором над элементами списка будут производиться операции, не детерминирован. в отличие от colletion_name.stream()
удачный пример
	Stream<Integer> numbersStream = Stream.of(1, 2, 3, 4, 5, 6);
	Integer result = numbersStream.parallel().reduce(1, (x,y)->x * y);
	System.out.println(result);
	Фактически здесь происходит перемножение чисел => порядок не важен. При этом нет разницы между 1 * 2 * 3 * 4 * (5 * 6) или 5 * 6 * 1 * (2 * 3) * 4.
Фактически применение параллельных потоков сводится к тому, 
что данные в потоке будут разделены на части, 
каждая часть обрабатывается на отдельном ядре процессора, 
и в конце эти части соединяются, 
и над ними выполняются финальные операции.
Когда параллелить?
	Размер данных. Чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.
	Количество ядер процессора. Если на машине одно ядро, нет смысла применять параллельные потоки.
	Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из ArrayList легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа LinkedList - не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.
	Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов
............СЕТИ............
